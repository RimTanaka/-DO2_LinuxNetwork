# Отчет по выполнению заданий

## 1. Инструмент ipcalc `sudo apt install ipcalc`

ipcalc - Калькулятор для расчета адресов в подсети и сетевых масок.

### 1.1 Сети и маски

1. Адрес сети `192.167.38.54/13`

Возможно расчитать математически
  IP-адрес `192.167.38.54`:

  192 -> `11000000`
  167 -> `10100111`
  38 -> `00100110`
  54 -> `00110110`
  `11000000.10100111.00100110.00110110`
  Маска /13 означает, что первые 13 битов установлены в 1, а остальные в 0:
    `11111111.11111000.00000000.00000000`
  IP-адрес: `11000000.10100111.00100110.00110110`
  Маска:    `11111111.11111000.00000000.00000000`
  Результат:`11000000.10100000.00000000.00000000`
  
  Разделим на октеты и преобразуем каждый обратно в десятичный формат:

  11000000 -> 192
  10100000 -> 160
  00000000 -> 0
  00000000 -> 0
  Адрес сети: `192.160.0.0`

   - Адрес сети: `192.160.0.0/13`
![192.167.38.54/13](./img/1_192.167.38.54_13.png)

2. Перевод масок
   - Маска `255.255.255.0`:
     - Префиксная запись: /24
     - Двоичная запись: `11111111.11111111.11111111.00000000`
![255.255.255.0](./img/1_255.255.255.0.png)

   - Маска /15:
     - Обычная запись: `255.254.0.0`
     - Двоичная запись: `11111111.11111110.00000000.00000000`
![/15](./img/1_15.png)

   - Маска `11111111.11111111.11111111.11110000`:
      11111111 -> 255
      11111111 -> 255
      11111111 -> 255
      11111111 -> 240
     - Обычная запись: `255.255.255.240`
     - Префиксная запись: /28
![1 255.255.255.240](./img/1_255.255.255.240.png)

3. Минимальный и максимальный хост в сети `12.167.38.4` при масках:
   - Маска /8:
     - Минимальный хост: `12.0.0.1`
     - Максимальный хост: `12.255.255.254`
![1 12.167.38.4 8](./img/1_12.167.38.4_8.png)
     

   - Маска `11111111.11111111.00000000.00000000` (/16):
      `11111111.11111111.00000000.00000000` = `255.255.0.0`
     - Минимальный хост: `12.167.0.1`
     - Максимальный хост: `12.167.255.254`
![1 12.167.38.4 255.255.0.0](./img/1_12.167.38.4_255.255.0.0.png)

   - Маска `255.255.254.0` (/23):
     - Минимальный хост: `12.167.38.1`
     - Максимальный хост: `12.167.39.254`
![1 12.167.38.4 255.255.254.0](./img/1_12.167.38.4_255.255.254.0.png)


   - Маска /4:
     - Минимальный хост: `0.0.0.1`
     - Максимальный хост: `15.255.255.254`
![1 12.167.38.4 4](./img/1_12.167.38.4_4.png)

### 1.2 localhost

Можно ли обратиться к приложению, работающему на localhost, со следующих IP:
`localhost` это адрес принадлежит к специальному диапазону адресов, который называется loopback.

Loopback адреса включают диапазон от `127.0.0.0` до `127.255.255.255`. Все адреса в этом диапазоне считаются локальными и используются для взаимодействия программ на одной и той же машине.
localhost, подразумевается использование адресов сети loopback, которая традиционно использует диапазон адресов `127.0.0.0/8`.

- `194.34.23.100`: Нет
- `127.0.0.2`: Да
- `127.1.0.1`: Да
- `128.0.0.1`: Нет

### 1.3 Диапазоны и сегменты сетей

Частные IP-адреса определены в трех диапазонах:

```
10.0.0.0 - 10.255.255.255 (Class A)
172.16.0.0 - 172.31.255.255 (Class B)
192.168.0.0 - 192.168.255.255 (Class C)
```
Эти диапазоны не маршрутизируются в интернете и используются для локальных сетей.

IP-адреса, не входящие в эти диапазоны, являются публичными и могут использоваться в интернете.

```
1. Публичные и частные IP:
   - 10.0.0.45: Частный
   - 134.43.0.2: Публичный
   - 192.168.4.2: Частный
   - 172.20.250.4: Частный
   - 172.0.2.1: Публичный
   - 192.172.0.1: Публичный
   - 172.68.0.2: Публичный
   - 172.16.255.255: Частный
   - 10.10.10.10: Частный
   - 192.169.168.1: Публичный
```


2. Возможные IP адреса шлюза в сети 10.10.0.0/18:

Для определения возможных IP-адресов шлюза в сети 10.10.0.0/18, необходимо знать, что маска /18 охватывает диапазон от 10.10.0.0 до 10.10.63.255. Маска /18 означает, что первые 18 бит определяют сеть, а оставшиеся 14 бит определяют хосты внутри этой сети.
![1 10.10.0.0 18](./img/1_10.10.0.0_18.png)

```
   - 10.0.0.1: Нет
   - 10.10.0.2: Да
   - 10.10.10.10: Да
   - 10.10.100.1: Нет
   - 10.10.1.255: Да
```

## 2. Статическая маршрутизация между двумя машинами

 Преднастройка для соединения между двумя внутренними машинами
![2 ws internal network.png](./img/2_ws_internal_network.png)

### Вызов команды `ip a` на ws1

![ws1_ip_a](./img/2_ws1_ip_a.png)

### Вызов команды `ip a` на ws2

![ws2_ip_a](./img/2_ws2_ip_a.png)

### Настройка сетевых интерфейсов

Содержание файла `/etc/netplan/00-installer-config.yaml` на ws1

```
network:
  ethernets:
    enp0s3:
      dhcp4: true
    enp0s8:
      dhcp4: false
      addresses: [192.168.100.10/16]
  version: 2
```
![2 ws1_conf](./img/2_ws1_conf.png)

```
network:
  ethernets:
    enp0s3:
      dhcp4: true
    enp0s8:
      dhcp4: false
      addresses: [172.24.116.8/12]
  version: 2
```
![2 ws2_conf](./img/2_ws2_conf.png)

ws1 and ws2 `sudo netplan apply`
![2 ws1 netplan applay.png](./img/2_ws1_netplan_applay.png)
![2 ws2 netplan applay.png](./img/2_ws2_netplan_applay.png)

### Добавление статического маршрута вручную

Добавление статического маршрута от одной машины до другой и обратно при помощи команды вида ip r add.

Пропингуем соединение между машинами.

ws1 `sudo ip r add 192.168.100.10 dev enp0s3`
![2 ws1 ip r add](./img/2_ws1_ip_r_add.png)

ws2 `sudo ip r add 172.24.116.8 dev enp0s3`
![2 ws2 ip r add](./img/2_ws2_ip_r_add.png)

ws1 `ping 172.24.116.8`
![2 ws1 ping dyn](./img/2_ws1_ping_dyn.png)

ws2 `ping 192.168.100.10`
![2 ws1 ping dyn](./img/2_ws2_ping_dyn.png)

### Добавление статического маршрута с сохранением

`sudo reboot`
![2 ws1 reboot](./img/2_ws1_reboot.png)
![2 ws2 reboot](./img/2_ws2_reboot.png)

Добавь статический маршрут от одной машины до другой с помощью файла /etc/netplan/00-installer-config.yaml.

ws1
```
network:
  ethernets:
    enp0s3:
      dhcp4: true
    enp0s8:
      dhcp4: false
      addresses: [192.168.100.10/16]
      routes:
              - to: 172.24.116.8
              via: 192.168.100.10
  version: 2
```
![2 ws1_new_conf](./img/2_ws1_new_conf.png)

ws2
```
network:
  ethernets:
    enp0s3:
      dhcp4: true
    enp0s8:
      dhcp4: false
      addresses: [172.24.116.8/12]
      routes:
              - to: 192.168.100.10
              via: 172.24.116.8
  version: 2
```
![2 ws2_new_conf](./img/2_ws2_new_conf.png)

ws1 and ws2 `sudo netplan apply`
![2 ws1 netplan applay.png](./img/2_ws1_netplan_applay.png)
![2 ws2 netplan applay.png](./img/2_ws2_netplan_applay.png)

ws1 `ping 172.24.116.8`
![2 ws1 ping stat](./img/2_ws1_ping_stat.png)

ws2 `ping 192.168.100.10`
![2 ws1 ping stat](./img/2_ws2_ping_stat.png)

## 3. Утилита iperf3

iperf3 — программа для измерения пропускной способности сети в реальном времени.

### 3.1. Скорость соединения

Переведи и запиши в отчёт:

```
8 Mbps = 1 MB/s(мегабит/c в мегабайт/c)

100 MB/s = 800000 Kbps(мегабайт/c в килобит/c)

1 Gbps = 1000 Mbps(гигабит/c в мегабит/c)
```

### 3.2 Утилита iperf3 `sudo apt install iperf3`

ws1
![3 ws1 inst iperf3](./img/3_ws1_inst_iperf3.png)

ws2
![3 ws2 inst iperf3](./img/3_ws2_inst_iperf3.png)

Измерь скорость соединения между ws1 и ws2.

На ws1 `iperf3 -s` - для перехода в режим прослушивания сервера

На ws2 `iperf3 -c 192.168.100.10` - Для отправки пакетов на ws1
![3 ws iperf3 result](./img/3_ws_iperf3_result.png)

## 4. Сетевой экран

### 4.1. Утилита iptables

Создай файл /etc/firewall.sh, имитирующий фаерволл, на ws1 и ws2:

```
#!/bin/sh

# Удаление всех правил в таблице «filter» (по-умолчанию).
iptables -F
iptables -X
```

Нужно добавить в файл подряд следующие правила:

1) На ws1 примени стратегию, когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5).

2) На ws2 примени стратегию, когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5).

3) Открой на машинах доступ для порта 22 (ssh) и порта 80 (http).

4) Запрети echo reply (машина не должна «пинговаться», т.е. должна быть блокировка на OUTPUT).

5) Разреши echo reply (машина должна «пинговаться»).

ws1
```
#!/bin/sh

# Удаление всех правил в таблице «filter» (по-умолчанию).
iptables -F
iptables -X

# Открываем доступ для порта 22 (ssh) и порта 80 (http)
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# Запретить echo reply (машина не должна пинговаться)
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j DROP

# Разрешить echo reply (машина должна пинговаться)
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT
```

ws2
```
#!/bin/sh

# Удаление всех правил в таблице «filter» (по-умолчанию).
iptables -F
iptables -X

# Открываем доступ для порта 22 (ssh) и порта 80 (http)
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# Разрешить echo reply (машина должна пинговаться)
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT

# Запретить echo reply (машина не должна пинговаться)
iptables -A OUTPUT -p icmp --icmp-type echo-reply -j DROP
```

![4 ws etc_firewall](./img/4_ws_etc_firewall.png)

Запусти файлы на обеих машинах командами:

```
sudo chmod +x /etc/firewall.sh
sudo /etc/firewall.sh
sudo iptables -L
```

![4 ws1 firewall_result](./img/4_ws_firewall_result.png)

Разница в том, что команды выполняются по порядку. Поэтому в ws1 пинг будет запрещен, так как запрещение стоит первее, а в ws2 будет разрешен, так как разрешение стоит первее.

### 4.2. Утилита nmap

Nmap — это инструмент командной строки Linux для исследования сети и проверки безопасности. Особенностью nmap является то, что эта утилита может определить, включен ли хост, даже если его нельзя пропинговать.

Командой ping найди машину, которая не «пингуется», после чего утилитой nmap покажи, что хост машины запущен.

Сначала пробуем пропинговать порт 192.168.100.10 - Не пингуется

Пингуем 172.24.116.8 - Все хорошо

Определяем, что WS1 не пингуется
![4 ws2 firewall_result](./img/4_ws_dop_firewall_result.png)

NMAP на обеих машинах проверил, что машины запущенны

![4 host_is_up](./img/4_host_is_up.png)

DUMP ws1
![4 ws1 dump](./img/4_ws1_dump.png)

DUMP ws2
![4 ws2 dump](./img/4_ws2_dump.png)



## 5. Статическая маршрутизация сети

**Сеть:**

![part5_network](./img/part5_network.png)

### 5.1. Настройка адресов машин

Подними пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2)).

Перед дальнейшими манипуляциями, во избежании лишних проблем, заранее обновим систему и установим утилиты для одной виртуальной машины, далее просто клонируйте ее сколько необходимо (r1, r2, ws11, ws21, ws22):

```
sudo apt-get update && sudo apt-get upgrade
sudo apt-get install -y mcedit ipcalc openssh-server apache2 isc-dhcp-server inetutils-traceroute traceroute nmap iptables iperf3
```
Клонируем необходимое количество машин:
![5.1 clone](./img/5.1_clone.png)
 
Настрой конфигурации машин в etc/netplan/00-installer-config.yaml на машинах R1 R2
![5.1 r1 r2 conf](./img/5.1_r1_r2_conf.png)
 
Настрой конфигурации машин в etc/netplan/00-installer-config.yaml на машинах WS11 WS21 WS22
![5.1 ws11 21 22 conf](./img/5.1_ws11_21_22_conf.png)

проверяем, что адрес машин задан верно `ip -4 a`

R1 R2

![5.1 r1 r2 ip](./img/5.1_r1_r2_ip.png)

WS11 WS21 WS22

![5.1 ws11 21 22 ip](./img/5.1_ws11_21_22_ip.png)

PING WS22 с WS21. PING R1 с WS11.

![5.1 ping](./img/5.1_ping.png)

### 5.2. Включение переадресации IP-адресов

Включаем переадресацию IP, выполняя команду на роутерах(r1, r2): `sudo sysctl -w net.ipv4.ip_forward=1`. При таком подходе переадресация не будет работать после перезагрузки системы.

![5.2 r1 sysctl dyn](./img/5.2_r1_sysctl_dyn.png)
![5.2 r2 sysctl dyn](./img/5.2_r2_sysctl_dyn.png)


Открыть файл /etc/sysctl.conf и добавь в него следующую строку:

`net.ipv4.ip_forward = 1`

При использовании этого подхода, IP-переадресация включена на постоянной основе.

![5.2 r1 sysctl stat](./img/5.2_r1_sysctl_stat.png)
![5.2 r2 sysctl stat](./img/5.2_r2_sysctl_stat.png)

### 5.3. Установка маршрута по-умолчанию

Настроика маршрута по-умолчанию (шлюз) для рабочих станций ws11, ws22, ws21:

![5.3 add routes](./img/5.3_add_routes.png)


Вызовим `ip r`, видим добавился маршрут в таблицу маршрутизации.

Пример вывода команды `ip r` после добавления шлюза:
```
default via 10.10.0.1 dev enp0s8
10.10.0.0/18 dev enp0s8 proto kernel scope link src 10.10.0.2
```

![5.3 ws11 ip r](./img/5.3_ws11_ip_r.png)
![5.3 ws21 ip r](./img/5.3_ws21_ip_r.png)
![5.3 ws22 ip r](./img/5.3_ws22_ip_r.png)

Пропингем с ws11 роутер r2 и покажим на r2, что пинг доходит. Для этого используем команду на r2 `tcpdump -tn -i enp0s8`

![5.3 ping ws11 r2](./img/5.3_ping_ws11_r2.png)

Не смотря на то, что ping говорить о том, что пакеты потеряны, мы видим на R2 что обращение к нему дошло

### 5.4. Добавление статических маршрутов

Добавим в роутеры r1 и r2 статические маршруты в файле конфигураций. 

Пример для r1 маршрута в сетку 10.20.0.0/26:

```
- to: 10.20.0.0
  via: 10.100.0.12
```

![5.4 add static router](./img/5.4_add_static_router.png)

Вызови ip r и покажи таблицы с маршрутами на обоих роутерах. 

Пример таблицы на r1:

```
10.100.0.0/16 dev eth1 proto kernel scope link src 10.100.0.11
10.20.0.0/26 via 10.100.0.12 dev eth1
10.10.0.0/18 dev enp0s8 proto kernel scope link src 10.10.0.1
```

![5.4 r1 r2 ip r](./img/5.4_r1_r2_ip_r.png)


Запусим команды на ws11 `ip r list 10.10.0.0/[маска сети]` и `ip r list 0.0.0.0/0`

![5.4 ws11 ip r list](./img/5.4_ws11_ip_r_list.png)

* Для адреса 10.10.0.0/[маска сети] был выбран маршрут, отличный от 0.0.0.0/0, потому что маска /18 описывает маршрут к сети точнее, в отличие от маски /0.

Специфичность маршрута: В таблице маршрутизации, если пакет может быть отправлен по нескольким маршрутам, выбирается самый специфичный маршрут. Маршрут к сети 10.10.0.0/18 более специфичен, чем маршрут по-умолчанию (0.0.0.0/0), так как он охватывает только определенную подсеть 10.10.0.0/18.

Приоритетность: Специфичные маршруты имеют более высокий приоритет по сравнению с общими маршрутами. Это означает, что маршрут к 10.10.0.0/18 будет использоваться для трафика, предназначенного для этой сети, даже если существует маршрут по-умолчанию.

### 5.5. Построение списка маршрутизаторов

Пример вывода утилиты `traceroute` после добавления шлюза:
```
1 10.10.0.1 0 ms 1 ms 0 ms
2 10.100.0.12 1 ms 0 ms 1 ms
3 10.20.0.10 12 ms 1 ms 3 ms
```

Запустим на r1 команду дампа `tcpdump -tnv -i enp0s8`

При помощи утилиты traceroute построим список маршрутизаторов на пути от ws11 до ws21.

![5.5 build list routes](./img/5.5_build_list_routes.png)

`traceroute` использует ICMP Echo Request или UDP пакеты для определения маршрута к целевому узлу. Принцип его работы основан на изменении значения поля TTL (Time To Live) в заголовке IP-пакета:

1. **Начальное значение TTL**: Отправляется пакет с TTL («время жизни») равным 1. Первый маршрутизатор на пути к цели уменьшает TTL на 1, что приводит к его обнулению. Маршрутизатор отклоняет пакет и отправляет обратно ICMP сообщение "Time Exceeded".

2. **Увеличение TTL**: `traceroute` затем увеличивает TTL на 1 и повторяет процесс. Второй маршрутизатор обрабатывает пакет аналогичным образом. Этот процесс повторяется, пока пакет не достигнет целевого узла.

3. **ICMP Echo Reply**: Когда пакет достигает целевого узла, целевой узел отвечает ICMP сообщением "Echo Reply", указывая, что пакет достиг своей цели.

На основании вывода `tcpdump` на r1, видно, что каждый маршрутизатор последовательно отвечает на пакеты `traceroute`, предоставляя информацию о своем IP-адресе и времени задержки (RTT).

### 5.6. Использование протокола ICMP при маршрутизации

Запустим на r1 перехват сетевого трафика, проходящего через enp0s8 с помощью команды `tcpdump -n -i enp0s8 icmp`

Пропингуй с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды:
`ping -c 1 10.30.0.111`

![5.6 ping](./img/5.6_ping.png)


Сохраним дампы образов виртуальных машин.

![5.6 dump](./img/5.6_dump.png)

## Part 6. Динамическая настройка IP с помощью DHCP

DHCP — протокол прикладного уровня модели TCP/IP, служит для назначения IP-адреса клиенту.

Для r2 настрой в файле `/etc/dhcp/dhcpd.conf` конфигурацию службы DHCP:

### 1) Укажи адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r2:

```
subnet 10.100.0.0 netmask 255.255.0.0 {}

subnet 10.20.0.0 netmask 255.255.255.192
{
    range 10.20.0.2 10.20.0.50;
    option routers 10.20.0.1;
    option domain-name-servers 10.20.0.1;
}
```

![6 r2 dhcpd](./img/6_r2_dhcpd.png)

### 2) В файле resolv.conf пропиши `nameserver 8.8.8.8`.

![6 r2 resolv](./img/6_r2_resolv.png)

* Перезагрузи службу DHCP командой systemctl restart isc-dhcp-server. 

* Машину ws21 перезагрузим при помощи `reboot` и через `ip a` покажем, что она получила адрес. Также пропингуй ws22 с ws21.

![6 r2 rest dhcp w21 ip a](./img/6_r2_rest_dhcp_w21_ip a.png)

ping ws22 c ws21

![6 ws21 ping ws22](./img/6_ws21_ping_ws22.png)

* Укажи MAC адрес у ws11, для этого в etc/netplan/00-installer-config.yaml надо добавить строки: `macaddress: 10:10:10:10:10:BA`, `dhcp4: true`.

![6 ws11 mac adr](./img/6_ws11_mac_adr.png)
![6 ws11 macaddress](./img/6_ws11_macaddress.png)

Для r1 настроим аналогично r2, но сделаем выдачу адресов с жесткой привязкой к MAC-адресу (ws11). Проведем аналогичные тесты.

1) Укажем адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r1:

```
subnet 10.100.0.0 netmask 255.255.255.192 {}

subnet 10.20.0.0 netmask 255.255.255.192
{
    range 10.20.0.2 10.20.0.50;
    option routers 10.20.0.1;
    option domain-name-servers 10.20.0.1;
    host ws11
    {
    gardware ethernet 10:10:10:10:10:BA;
    fixed-address 10.10.0.50;
    }
}
```

![6 r2 dhcpd](./img/6_r1_dhcpd.png)

2) В файле resolv.conf пропишим `nameserver 8.8.8.8`.
![6 r1 resolv](./img/6_r1_resolv.png)

Перезагрузить службу DHCP командой `systemctl restart isc-dhcp-server`. Машину ws11 перезагрузить при помощи reboot и через `ip a` показать, что она получила адрес.

![6 r1 rest dhcp w11 ip a](./img/6_r1_rest_dhcp_w11_ip_a.png)

Запроси с ws21 ip адрес **ДО**.

![6 ws21 ip addr show enp0s8 do](./img/6_ws21_ip_addr_show_enp0s8_do.png)

Для отображения IP-адреса интерфейса enp0s8 можно использовать команду `ip addr show enp0s8`. Она покажет информацию о сетевом интерфейсе enp0s8, включая его IP-адрес. Если IP-адрес на интерфейсе не настроен, команда вернет пустой вывод для этого интерфейса.

`sudo dhclient -r enp0s8` - для обновления IP-адреса интерфейса с помощью команды dhclient можно использовать флаг -r, который предназначен для освобождения текущего IP-адреса и запуска процесса запроса нового адреса у DHCP-сервера. 

После этого можно запустить команду `dhclient` без каких-либо дополнительных флагов для получения нового IP-адреса от DHCP-сервера.

Запросить с ws21 обновление ip адреса **После**.

![6 ws21 ip addr show enp0s8 posle](./img/6_ws21_ip_addr_show_enp0s8_posle.png)


### Опции DHCP сервера, использованные в данном пункте:

- `range`: диапазон выдаваемых IP-адресов.
- `option routers`: адрес маршрутизатора по умолчанию.
- `option domain-name-servers`: адрес DNS-сервера.
- `host`: привязка IP-адреса к MAC-адресу.

Сохрани дампы образов виртуальных машин.

![6 dump](./img/6_dump.png)




## 7. NAT

В данном задании используются виртуальные машины из Части 5.

![7 snap 5](./img/7_snap_5.png)

В файле `/etc/apache2/ports.conf` на ws22 и r1 измени строку `Listen 80` на `Listen 0.0.0.0:80`, то есть сделай сервер Apache2 общедоступным.

![7 ports](./img/7_ports.png)

Запусти веб-сервер Apache командой `service apache2 start` на ws22 и r1.
Для наглядности `service apache2 start`

![7 start apache2](./img/7_start_apache2.png)

ping r1 - w22 до подключения фаервола

![7 no firewall ping r1-w22](./img/7_no_firewall_ping_r1-w22.png)


Добавь в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:

1) Удаление правил в таблице filter - iptables -F;

2) Удаление правил в таблице "NAT" - iptables -F -t nat;

3) Отбрасывать все маршрутизируемые пакеты - iptables --policy FORWARD DROP.

Запусти файл также, как в Части 4.

Запустить файл, предоставив соответствующие права доступа к нему: `sudo chmod +x /etc/firewall.sh` и `sudo sh /etc/firewall.sh`. Проверить список всех правил командой `sudo iptables -L`

![7 r2 firewall 1](./img/7_r2_firewall_1.png)

Проверь соединение между ws22 и r1 командой ping.
__При запуске файла с этими правилами, ws22 не должна «пинговаться» с r1.__

![7 NO ping r1-ws22](./img/7_NO_ping_r1-ws22.png)


Добавь в файл ещё одно правило:

4) Разрешить маршрутизацию всех пакетов протокола ICMP.

Запусти файл также, как в Части 4.

![7 r2 firewall 2](./img/7_r2_firewall_2.png)

Проверь соединение между ws22 и r1 командой ping.
__При запуске файла с этими правилами, ws22 должна «пинговаться» с r1.__

![7 YES ping r1-ws22](./img/7_YES_ping_r1-ws22.png)


Добавь в файл ещё два правила:

5) Включи SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0).

`sudo iptables -t nat -A POSTROUTING -o enp0s8 -s 10.20.0.20/26 -j SNAT --to-source 10.100.0.12`

6) Включи DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети.

`sudo iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 10.20.0.20:80`

Запусти файл также, как в Части 4.

![7 r2 firewall 3 stat](./img/7_r2_firewall_3_stat.png)


`Перед тестированием рекомендуется отключить сетевой интерфейс NAT (его наличие можно проверить командой ip a) в VirtualBox, если он включен.`


Проверь соединение по TCP для SNAT: для этого с ws22 подключиться к серверу Apache на r1 командой `sudo telnet 10.100.0.11 80`

![7 ws22 r1 telnet](./img/7_ws22_r1_telnet.png)


Проверь соединение по TCP для DNAT: для этого с r1 подключиться к серверу Apache на ws22 командой telnet (обращаться по адресу r2 и порту 8080).

![7 r1 ws22 telnet](./img/7_r1_ws22_telnet.png)


Сохрани дампы образов виртуальных машин.

![7 dump](./img/7_dump.png)





## 8. Дополнительно. Знакомство с SSH Tunnels

__В данном задании используются виртуальные машины из Части 5.__

![8 start](./img/8_start.png)

Перед тем как начать, пробросим порт 22 на ws11 ws21 ws22, для этого `Настройки -> Сети -> Адаптер 1 (NAT), Адаптер 2 (внутренняя сеть), в первом адаптере нажать Дополнительно -> Проброс портов -> зеленую кнопку Добавить новое правило для проброса портов  -> Порт хоста 80 > Порт Гостя 22 -> OK`

Проделать для всех трех машин(ws11 ws21 ws22)

![8 port 22 add 1](./img/8_port_22_add 1.png)
![8 port 22 add 2](./img/8_port 22_add 2.png)

### Запусти на r2 фаервол с правилами из Части 7.

![8 firewall](./img/8_firewall.png)

### Запусти веб-сервер Apache на ws22 только на localhost (то есть в файле /etc/apache2/ports.conf измени строку Listen 80 на Listen localhost:80).

![8 start apache2 localhast](./img/8_start_apache2_localhast.png)


На трех машинах ws11 ws21 ws22 `sudo vim /etc/ssh/sshd_config`:

Раскоментируем `Port 22`

Раскоментируем `ListenAddress 0.0.0.0`

Раскоментируем `ListenAddress ::`

![8 sshd_config](./img/8_ws11_sshd_config.png)
![8 sshd_config](./img/8_ws21_sshd_config.png)
![8 sshd_config](./img/8_ws22_sshd_config.png)

Проверяем, чтобы `#GatewayPorts no` было закоментированно - Команда отвечает за то, разрешено ли ssh соединение между локальными машинами

![8 sshd_config GatewayPort](./img/8_sshd_config_GatewayPort.png)

Перезапускаем sshd: `sudo systemctl restart sshd`

Проверяем статус sshd: `sudo systemctl status sshd`

![8 restart sshd](./img/8_restart_sshd.png)


### Воспользуйся Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21.

шаблон команды `ssh -L 8080:localhost:80 <username>@<IP-адрес ws22>`

На ws21 `ssh -L 8080:localhost:80 a@10.20.0.20`

![8 ws21 - ws22 ssh connect](./img/8_ws21-ws22_ssh_connect.png)


### Воспользуйся Remote TCP forwarding c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11.

Чтобы получить доступ с ws11 -> ws22 нужно изменить правила iptables на R2
```
sudo iptables -A FORWARD -p tcp --dports 80 -j ACCEPT
sudo iptables -A FORWARD -p tcp --sports 80 -j ACCEPT
```

Заменить на 
```
sudo iptables -A FORWARD -p tcp -m multiport --dports 22,80 -j ACCEPT
sudo iptables -A FORWARD -p tcp -m multiport --sports 22,80 -j ACCEPT
```

`-m multiport` - позволяет указывать несколько портов для одного правила;

`--dports 22,80` - порты на которые разрешен доступ (destination ports);

`--sports 22,80,8080` - фильтр по портам отправителя, разрешает соединения с портами 22, 80.

![8 r2 firewal Remote tcp](./img/8_r2_firewal_Remote tcp.png)

Проверяем доходит ли пинг с ws22 -> ws11, за одно проверяем корректно ли работает SNAT (должен быть подмененный ip `10.100.0.12`)

ws11 - `sudo tcpdump -t -i enp0s8`

ws22 - `ping 10.10.0.2`

![8 ping ws11 dcpdump](./img/8_ping_ws11_dcpdump.png)

Так как мы не можем соедениться с ws11 напрямую к ws22(А если можем, то что-то сделано не так) -> соеденяем ws11 -> ws21, а оттуда подключаемся с ws21->ws22. Эта схема работает потому что подмена ip идет на роутере r2, в то время как машины ws21 и ws22 находятся внутри локальной сети и так как подменя идет только на ws22, мы можем подключиться в ws21, а от туда, соответственно у нас будет допуск к локальной сети ws21, что позволит подключиться к ws22.

На ws11 соединяемся к ws21 `ssh -R 8080:localhost:80 a@10.20.0.10`

![8 ws11 - ws21 ssh connect](./img/8_ws11-ws21_ssh_connect.png)

Теперь подключившись с ws11 к ws21 -> Локально подключаемся к ws22 `ssh -L 8080:localhost:80 a@10.20.0.20`

![8 ws11-ws21- local connect ws22](./img/8_ws11-ws21-local_connect ws22.png)

Таким путем мы подключились с ws11 к ws22, ip которого скрыт от внешних сетей через SNAT

![8 ws11 - ws22 connected](./img/8_ws11-ws22_connected.png)

### Для проверки, сработало ли подключение в обоих предыдущих пунктах, перейди во второй терминал (например, клавишами Alt + F2) и выполни команду:
`telnet 127.0.0.1 [локальный порт]`

![8 result telnet](./img/8_result_telnet.png)

### Сохрани дампы образов виртуальных машин.

![8 dump](./img/8_dump.png)

